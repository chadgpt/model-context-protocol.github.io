{"/resources/":{"data":{"":"Model Context Protocol (MCP) 提供多种文档和实现资源：\n用户文档: 访问 model-context-protocol.mintlify.app 获取全面的用户文档 Python SDK: Python 实现可在 github.com/modelcontextprotocol/python-sdk 获取 - 讨论 规范: 核心规范可在 github.com/modelcontextprotocol/specification 获取 - 讨论 TypeScript SDK: TypeScript 实现可在 github.com/modelcontextprotocol/typescript-sdk 获取 - 讨论 如有问题或讨论，请在相应的 GitHub 仓库中打开讨论，基于您的实现或用例。您也可以访问 Model Context Protocol 组织在 GitHub 上 查看所有仓库和正在进行的开发。"},"title":"其他资源"},"/specification/":{"data":{"":" ℹ️ 协议修订: 2024-11-05 Model Context Protocol (MCP) 是一个开放协议，能够在 LLM 应用程序和外部数据源及工具之间实现无缝集成。无论您是在构建 AI 驱动的 IDE、增强聊天界面，还是创建自定义 AI 工作流，MCP 都提供了一种标准化的方式来连接 LLM 与所需的上下文。\n本规范定义了权威的协议要求，基于 schema.ts 中的 TypeScript 模式。\n有关实施指南和示例，请访问 model-context-protocol.mintlify.app。\n本文件中的关键字 “MUST”、“MUST NOT”、“REQUIRED”、“SHALL”、“SHALL NOT”、“SHOULD”、“SHOULD NOT”、“RECOMMENDED”、“NOT RECOMMENDED”、“MAY” 和 “OPTIONAL” 应按照 BCP 14 [RFC2119] [RFC8174] 中的描述进行解释，仅当它们以全大写形式出现时，如此处所示。","了解更多#了解更多":"探索每个协议组件的详细规范：\n架构 基础协议 服务器功能 客户端功能 贡献 ","关键细节#关键细节":"基础协议 JSON-RPC 消息格式 有状态连接 服务器和客户端功能协商 功能 服务器向客户端提供以下任何功能：\n资源: 上下文和数据，供用户或 AI 模型使用 提示: 为用户提供的模板消息和工作流 工具: 供 AI 模型执行的功能 客户端可以向服务器提供以下功能：\n采样: 服务器发起的代理行为和递归 LLM 交互 其他实用工具 配置 进度跟踪 取消 错误报告 日志记录 ","安全和信任与安全#安全和信任与安全":"Model Context Protocol 通过任意数据访问和代码执行路径提供强大的功能。随着这种能力的增强，所有实施者必须仔细解决重要的安全和信任问题。\n关键原则 用户同意和控制\n用户必须明确同意并理解所有数据访问和操作 用户必须保留对共享数据和采取行动的控制权 实施者应提供清晰的用户界面，用于审查和授权活动 数据隐私\n主机必须在向服务器公开用户数据之前获得用户的明确同意 主机不得在未经用户同意的情况下传输资源数据 用户数据应受到适当的访问控制保护 工具安全\n工具代表任意代码执行，必须谨慎对待 主机必须在调用任何工具之前获得用户的明确同意 用户应在授权使用工具之前了解每个工具的功能 LLM 采样控制\n用户必须明确批准任何 LLM 采样请求 用户应控制： 是否进行采样 将发送的实际提示 服务器可以看到的结果 协议有意限制了服务器对提示的可见性 实施指南 虽然 MCP 本身无法在协议级别强制执行这些安全原则，但实施者 应：\n在其应用程序中构建健全的同意和授权流程 提供清晰的安全影响文档 实施适当的访问控制和数据保护 在其集成中遵循安全最佳实践 在其功能设计中考虑隐私影响 ","概述#概述":"MCP 提供了一种标准化的方式，使应用程序能够：\n与语言模型共享上下文信息 向 AI 系统公开工具和功能 构建可组合的集成和工作流 该协议使用 JSON-RPC 2.0 消息在以下各方之间建立通信：\nHosts: 发起连接的 LLM 应用程序 Clients: 主机应用程序中的连接器 Servers: 提供上下文和功能的服务 MCP 从 Language Server Protocol 中汲取了一些灵感，该协议标准化了如何在整个开发工具生态系统中添加编程语言支持。类似地，MCP 标准化了如何将额外的上下文和工具集成到 AI 应用程序的生态系统中。"},"title":"规范"},"/specification/architecture/":{"data":{"":"Model Context Protocol (MCP) 遵循客户端-主机-服务器架构，每个主机可以运行多个客户端实例。此架构使用户能够在应用程序中集成 AI 功能，同时保持明确的安全边界和隔离关注点。基于 JSON-RPC，MCP 提供了一个有状态的会话协议，专注于上下文交换和客户端与服务器之间的采样协调。","功能协商#功能协商":"Model Context Protocol 使用基于功能的协商系统，客户端和服务器在初始化期间明确声明其支持的功能。功能确定会话期间可用的协议功能和原语。\n服务器声明资源订阅、工具支持和提示模板等功能 客户端声明采样支持和通知处理等功能 双方必须在整个会话期间尊重声明的功能 可以通过协议扩展协商额外的功能 sequenceDiagram participant Host participant Client participant Server Host-\u003e\u003e+Client: 初始化客户端 Client-\u003e\u003e+Server: 使用功能初始化会话 Server--\u003e\u003eClient: 响应支持的功能 Note over Host,Server: 具有协商功能的活动会话 loop 客户端请求 Host-\u003e\u003eClient: 用户或模型发起的操作 Client-\u003e\u003eServer: 请求（工具/资源） Server--\u003e\u003eClient: 响应 Client--\u003e\u003eHost: 更新 UI 或响应模型 end loop 服务器请求 Server-\u003e\u003eClient: 请求（采样） Client-\u003e\u003eHost: 转发给 AI Host--\u003e\u003eClient: AI 响应 Client--\u003e\u003eServer: 响应 end loop 通知 Server--)Client: 资源更新 Client--)Server: 状态变化 end Host-\u003e\u003eClient: 终止 Client-\u003e\u003e-Server: 结束会话 deactivate Server每个功能解锁会话期间可用的特定协议功能。例如：\n实现的 服务器功能 必须在服务器的功能中声明 发出资源订阅通知需要服务器声明订阅支持 工具调用需要服务器声明工具功能 采样 需要客户端在其功能中声明支持 这种功能协商确保客户端和服务器对支持的功能有清晰的理解，同时保持协议的可扩展性。","核心组件#核心组件":"graph LR subgraph \"应用主机进程\" H[主机] C1[客户端 1] C2[客户端 2] C3[客户端 3] H --\u003e C1 H --\u003e C2 H --\u003e C3 end subgraph \"本地机器\" S1[服务器 1\n文件 \u0026 Git] S2[服务器 2\n数据库] R1[(\"本地\n资源 A\")] R2[(\"本地\n资源 B\")] C1 --\u003e S1 C2 --\u003e S2 S1 \u003c--\u003e R1 S2 \u003c--\u003e R2 end subgraph \"互联网\" S3[服务器 3\n外部 API] R3[(\"远程\n资源 C\")] C3 --\u003e S3 S3 \u003c--\u003e R3 end主机 主机进程充当容器和协调者：\n创建和管理多个客户端实例 控制客户端连接权限和生命周期 执行安全策略和同意要求 处理用户授权决策 协调 AI/LLM 集成和采样 管理跨客户端的上下文聚合 客户端 每个客户端由主机创建，并维护一个隔离的服务器连接：\n为每个服务器建立一个有状态的会话 处理协议协商和功能交换 双向路由协议消息 管理订阅和通知 维护服务器之间的安全边界 主机应用程序创建和管理多个客户端，每个客户端与特定服务器具有 1:1 关系。\n服务器 服务器提供专门的上下文和功能：\n通过 MCP 原语公开资源、工具和提示 独立运行，具有明确的职责 通过客户端接口请求采样 必须遵守安全约束 可以是本地进程或远程服务 ","消息类型#消息类型":"MCP 定义了基于 JSON-RPC 2.0 的三种核心消息类型：\n请求: 带有方法和参数的双向消息，期望响应 响应: 匹配特定请求 ID 的成功结果或错误 通知: 不需要响应的单向消息 每种消息类型都遵循 JSON-RPC 2.0 规范的结构和传递语义。","设计原则#设计原则":"MCP 建立在几个关键设计原则之上，这些原则指导其架构和实现：\n服务器应该非常容易构建\n主机应用程序处理复杂的编排职责 服务器专注于特定的、明确的功能 简单的接口最小化实现开销 明确的分离使代码易于维护 服务器应该高度可组合\n每个服务器在隔离中提供专注的功能 多个服务器可以无缝组合 共享协议实现互操作性 模块化设计支持可扩展性 服务器不应读取整个对话，也不应“看到”其他服务器\n服务器仅接收必要的上下文信息 完整的对话历史保留在主机中 每个服务器连接保持隔离 跨服务器交互由主机控制 主机进程执行安全边界 功能可以逐步添加到服务器和客户端\n核心协议提供最少的必需功能 需要时可以协商额外的功能 服务器和客户端独立演进 协议设计为未来可扩展 保持向后兼容性 "},"title":"架构"},"/specification/basic/":{"data":{"":" ℹ️ 协议修订: 2024-11-05 所有 MCP 客户端和服务器之间的消息 必须 遵循 JSON-RPC 2.0 规范。该协议定义了三种基本类型的消息：\n类型 描述 要求 Requests 用于启动操作的消息 必须包含唯一 ID 和方法名称 Responses 回复请求的消息 必须包含与请求相同的 ID Notifications 无需回复的单向消息 不得包含 ID Responses 进一步分为 成功结果 或 错误。结果可以遵循任何 JSON 对象结构，而错误必须至少包含错误代码和消息。","协议层#协议层":"Model Context Protocol 由多个关键组件组成，这些组件协同工作：\n基础协议: 核心 JSON-RPC 消息类型 生命周期管理: 连接初始化、功能协商和会话控制 服务器功能: 服务器公开的资源、提示和工具 客户端功能: 客户端提供的采样和根目录列表 实用工具: 跨领域关注点，如日志记录和参数完成 所有实现 必须 支持基础协议和生命周期管理组件。其他组件 可以 根据应用程序的具体需求实现。\n这些协议层建立了明确的关注点分离，同时使客户端和服务器之间的丰富交互成为可能。模块化设计允许实现仅支持所需的功能。\n有关不同组件的更多详细信息，请参见以下页面：\n生命周期 资源 提示 工具 日志记录 采样 ","模式#模式":"协议的完整规范定义为 TypeScript 模式。这是所有协议消息和结构的真实来源。\n还有一个 JSON 模式，它是从 TypeScript 真实来源自动生成的，用于各种自动化工具。","认证#认证":"认证和授权目前不是 MCP 核心规范的一部分，但我们正在考虑在未来引入它们。加入我们的 GitHub 讨论，帮助塑造协议的未来！\n客户端和服务器 可以 协商自己的自定义认证和授权策略。"},"title":"基础协议"},"/specification/basic/lifecycle/":{"data":{"":" ℹ️ 协议修订: 2024-11-05 Model Context Protocol (MCP) 定义了一个严格的客户端-服务器连接生命周期，确保正确的功能协商和状态管理。\n初始化: 功能协商和协议版本协议 操作: 正常的协议通信 关闭: 优雅地终止连接 sequenceDiagram participant Client participant Server Note over Client,Server: 初始化阶段 activate Client Client-\u003e\u003e+Server: 初始化请求 Server--\u003e\u003eClient: 初始化响应 Client--)Server: 初始化通知 Note over Client,Server: 操作阶段 rect rgb(200, 220, 250) note over Client,Server: 正常的协议操作 end Note over Client,Server: 关闭 Client--)-Server: 断开连接 deactivate Server Note over Client,Server: 连接关闭","生命周期阶段#生命周期阶段":"初始化 初始化阶段 必须 是客户端和服务器之间的第一次交互。在此阶段，客户端和服务器：\n建立协议版本兼容性 交换和协商功能 共享实现细节 客户端 必须 通过发送包含以下内容的 initialize 请求来启动此阶段：\n支持的协议版本 客户端功能 客户端实现信息 { \"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"initialize\", \"params\": { \"protocolVersion\": \"2024-11-05\", \"capabilities\": { \"roots\": { \"listChanged\": true }, \"sampling\": {} }, \"clientInfo\": { \"name\": \"ExampleClient\", \"version\": \"1.0.0\" } } } 服务器 必须 以其自己的功能和信息进行响应：\n{ \"jsonrpc\": \"2.0\", \"id\": 1, \"result\": { \"protocolVersion\": \"2024-11-05\", \"capabilities\": { \"logging\": {}, \"prompts\": { \"listChanged\": true }, \"resources\": { \"subscribe\": true, \"listChanged\": true }, \"tools\": { \"listChanged\": true } }, \"serverInfo\": { \"name\": \"ExampleServer\", \"version\": \"1.0.0\" } } } 成功初始化后，客户端 必须 发送 initialized 通知以表示其准备开始正常操作：\n{ \"jsonrpc\": \"2.0\", \"method\": \"notifications/initialized\" } 在服务器响应 initialize 请求之前，客户端 不应 发送除 pings 之外的请求。 在收到 initialized 通知之前，服务器 不应 发送除 pings 和 logging 之外的请求。 版本协商 在 initialize 请求中，客户端 必须 发送其支持的协议版本。这 应 是客户端支持的 最新 版本。\n如果服务器支持请求的协议版本，则 必须 以相同的版本进行响应。否则，服务器 必须 以其支持的另一个协议版本进行响应。这 应 是服务器支持的 最新 版本。\n如果客户端不支持服务器响应中的版本，则 应 断开连接。\n功能协商 客户端和服务器功能确定会话期间可用的可选协议功能。\n关键功能包括：\n类别 功能 描述 客户端 roots 提供文件系统 roots 的能力 客户端 sampling 支持 LLM sampling 请求 客户端 experimental 描述对非标准实验功能的支持 服务器 prompts 提供 提示模板 服务器 resources 提供可读的 资源 服务器 tools 公开可调用的 工具 服务器 logging 发出结构化的 日志消息 服务器 experimental 描述对非标准实验功能的支持 功能对象可以描述子功能，如：\nlistChanged: 支持列表更改通知（用于提示、资源和工具） subscribe: 支持订阅单个项目的更改（仅限资源） 操作 在操作阶段，客户端和服务器根据协商的功能交换消息。\n双方 应：\n尊重协商的协议版本 仅使用成功协商的功能 关闭 在关闭阶段，一方（通常是客户端）干净地终止协议连接。没有定义特定的关闭消息——相反，应使用底层传输机制来表示连接终止：\nstdio 对于 stdio 传输，客户端 应 通过以下步骤启动关闭：\n首先，关闭到子进程（服务器）的输入流 等待服务器退出，或者如果服务器在合理时间内未退出，则发送 SIGTERM 如果服务器在 SIGTERM 后的合理时间内仍未退出，则发送 SIGKILL 服务器 可以 通过关闭其到客户端的输出流并退出来启动关闭。\nHTTP 对于 HTTP 传输，关闭通过关闭相关的 HTTP 连接来表示。","错误处理#错误处理":"实现 应 准备处理以下错误情况：\n协议版本不匹配 功能协商失败 初始化请求超时 关闭超时 实现 应 为所有请求实现适当的超时，以防止连接挂起和资源耗尽。\n初始化错误示例：\n{ \"jsonrpc\": \"2.0\", \"id\": 1, \"error\": { \"code\": -32602, \"message\": \"不支持的协议版本\", \"data\": { \"supported\": [\"2024-11-05\"], \"requested\": \"1.0.0\" } } } "},"title":"生命周期"},"/specification/basic/messages/":{"data":{"":" ℹ️ 协议修订: 2024-11-05 MCP 中的所有消息 必须 遵循 JSON-RPC 2.0 规范。该协议定义了三种类型的消息：","响应#响应":"响应是对请求的回复。\n{ jsonrpc: \"2.0\"; id: string | number; result?: { [key: string]: unknown; } error?: { code: number; message: string; data?: unknown; } } 响应 必须 包含与其对应请求相同的 ID。 必须设置 result 或 error 之一。响应 不得 同时设置两者。 错误代码 必须 是整数。 ","请求#请求":"请求从客户端发送到服务器或反之亦然。\n{ jsonrpc: \"2.0\"; id: string | number; method: string; params?: { [key: string]: unknown; }; } 请求 必须 包含一个字符串或整数 ID。 与基础 JSON-RPC 不同，ID 不得 为 null。 请求 ID 不得 在同一会话中被请求者重复使用。 ","通知#通知":"通知从客户端发送到服务器或反之亦然。它们不期望得到响应。\n{ jsonrpc: \"2.0\"; method: string; params?: { [key: string]: unknown; }; } 通知 不得 包含 ID。 "},"title":"消息"},"/specification/basic/transports/":{"data":{"":" ℹ️ 协议修订: 2024-11-05 MCP 目前定义了两种用于客户端-服务器通信的标准传输机制：\nstdio，通过标准输入和标准输出进行通信 HTTP with Server-Sent Events (SSE) 客户端 应 尽可能支持 stdio。\n客户端和服务器也可以以可插拔的方式实现 自定义传输。","http-with-sse#HTTP with SSE":"在 SSE 传输中，服务器作为独立进程运行，可以处理多个客户端连接。\n服务器 必须 提供两个端点：\n一个 SSE 端点，供客户端建立连接并接收来自服务器的消息 一个常规的 HTTP POST 端点，供客户端向服务器发送消息 当客户端连接时，服务器 必须 发送一个 endpoint 事件，其中包含一个 URI，供客户端用于发送消息。所有后续的客户端消息 必须 作为 HTTP POST 请求发送到此端点。\n服务器消息作为 SSE message 事件发送，消息内容以 JSON 编码在事件数据中。\nsequenceDiagram participant Client participant Server Client-\u003e\u003eServer: 打开 SSE 连接 Server-\u003e\u003eClient: endpoint 事件 loop 消息交换 Client-\u003e\u003eServer: HTTP POST 消息 Server-\u003e\u003eClient: SSE 消息事件 end Client-\u003e\u003eServer: 关闭 SSE 连接","stdio#stdio":"在 stdio 传输中：\n客户端将 MCP 服务器作为子进程启动。 服务器在其标准输入 (stdin) 上接收 JSON-RPC 消息，并将响应写入其标准输出 (stdout)。 消息以换行符分隔，不得 包含嵌入的换行符。 服务器 可以 将 UTF-8 字符串写入其标准错误 (stderr) 进行日志记录。客户端 可以 捕获、转发或忽略此日志记录。 服务器 不得 向其 stdout 写入任何不是有效 MCP 消息的内容。 客户端 不得 向服务器的 stdin 写入任何不是有效 MCP 消息的内容。 sequenceDiagram participant Client participant Server Process Client-\u003e\u003e+Server Process: 启动子进程 loop 消息交换 Client-\u003e\u003eServer Process: 写入 stdin Server Process-\u003e\u003eClient: 写入 stdout Server Process--)Client: 可选的 stderr 日志 end Client-\u003e\u003eServer Process: 关闭 stdin，终止子进程 deactivate Server Process","自定义传输#自定义传输":"客户端和服务器 可以 实现其他自定义传输机制，以满足其特定需求。该协议是传输无关的，可以在任何支持双向消息交换的通信通道上实现。\n选择支持自定义传输的实现者 必须 确保它们保留 MCP 定义的 JSON-RPC 消息格式和生命周期要求。自定义传输 应 记录其特定的连接建立和消息交换模式，以帮助互操作性。"},"title":"传输"},"/specification/basic/utilities/":{"data":{"":" ℹ️ 协议修订: 2024-11-05 这些可选功能通过各种实用工具增强了基础协议功能。\nPing 取消 进度 "},"title":"实用工具"},"/specification/basic/utilities/cancellation/":{"data":{"":" ℹ️ 协议修订: 2024-11-05 Model Context Protocol (MCP) 通过通知消息支持对正在进行的请求的可选取消。任一方都可以发送取消通知，以指示应终止先前发出的请求。","取消流程#取消流程":"当一方希望取消正在进行的请求时，它会发送一个包含以下内容的 notifications/cancelled 通知：\n要取消的请求的 ID 可选的原因字符串，可以记录或显示 { \"jsonrpc\": \"2.0\", \"method\": \"notifications/cancelled\", \"params\": { \"requestId\": \"123\", \"reason\": \"用户请求取消\" } } ","实施说明#实施说明":" 双方 应 记录取消原因以进行调试 应用程序 UI 应 指示何时请求取消 ","时间考虑#时间考虑":"由于网络延迟，取消通知可能在请求处理完成后到达，并可能在响应已发送后到达。\n双方 必须 优雅地处理这些竞争条件：\nsequenceDiagram participant Client participant Server Client-\u003e\u003eServer: 请求 (ID: 123) Note over Server: 开始处理 Client--)Server: notifications/cancelled (ID: 123) alt Note over Server: 处理可能在取消到达之前已完成 else 如果未完成 Note over Server: 停止处理 end","行为要求#行为要求":" 取消通知 必须 仅引用以下请求： 先前在相同方向上发出的请求 被认为仍在进行中的请求 客户端 不得 取消 initialize 请求 取消通知的接收者 应： 停止处理被取消的请求 释放相关资源 不发送被取消请求的响应 如果出现以下情况，接收者 可以 忽略取消通知： 引用的请求未知 处理已完成 请求无法取消 取消通知的发送者 应 忽略随后到达的请求响应 ","错误处理#错误处理":"无效的取消通知 应 被忽略：\n未知的请求 ID 已完成的请求 格式错误的通知 这保持了通知的“发送即忘”性质，同时允许在异步通信中处理竞争条件。"},"title":"取消"},"/specification/basic/utilities/ping/":{"data":{"":" ℹ️ 协议修订: 2024-11-05 Model Context Protocol 包括一个可选的 ping 机制，允许任一方验证其对方是否仍然响应并且连接是否存活。","使用模式#使用模式":"sequenceDiagram participant Sender participant Receiver Sender-\u003e\u003eReceiver: ping 请求 Receiver-\u003e\u003eSender: 空响应","实施考虑#实施考虑":" 实现 应 定期发出 ping 以检测连接健康状况 ping 的频率 应 可配置 超时 应 适合网络环境 应避免过度 ping 以减少网络开销 ","概述#概述":"ping 功能通过简单的请求/响应模式实现。客户端或服务器都可以通过发送 ping 请求来发起 ping。","消息格式#消息格式":"ping 请求是一个没有参数的标准 JSON-RPC 请求：\n{ \"jsonrpc\": \"2.0\", \"id\": \"123\", \"method\": \"ping\" } ","行为要求#行为要求":" 接收者 必须 及时响应一个空响应： { \"jsonrpc\": \"2.0\", \"id\": \"123\", \"result\": {} } 如果在合理的超时时间内未收到响应，发送者 可以： 认为连接已失效 终止连接 尝试重新连接程序 ","错误处理#错误处理":" 超时 应 被视为连接失败 多次 ping 失败 可以 触发连接重置 实现 应 记录 ping 失败以进行诊断 "},"title":"Ping"},"/specification/basic/utilities/progress/":{"data":{"":" ℹ️ 协议修订: 2024-11-05 Model Context Protocol (MCP) 通过通知消息支持对长时间运行操作的可选进度跟踪。任一方都可以发送进度通知，以提供有关操作状态的更新。","实施说明#实施说明":" 发送者和接收者 应 跟踪活动进度令牌 双方 应 实施速率限制以防止泛滥 进度通知 必须 在完成后停止 ","行为要求#行为要求":" 进度通知 必须 仅引用以下令牌：\n在活动请求中提供的令牌 与正在进行的操作相关联的令牌 进度请求的接收者 可以：\n选择不发送任何进度通知 以其认为合适的频率发送通知 如果未知，则省略总值 sequenceDiagram participant Sender participant Receiver Note over Sender,Receiver: 带有进度令牌的请求 Sender-\u003e\u003eReceiver: 带有 progressToken 的方法请求 Note over Sender,Receiver: 进度更新 loop 进度更新 Receiver--\u003e\u003eSender: 进度通知 (0.2/1.0) Receiver--\u003e\u003eSender: 进度通知 (0.6/1.0) Receiver--\u003e\u003eSender: 进度通知 (1.0/1.0) end Note over Sender,Receiver: 操作完成 Receiver-\u003e\u003eSender: 方法响应","进度流程#进度流程":"当一方希望 接收 请求的进度更新时，它会在请求元数据中包含一个 progressToken。\n进度令牌 必须 是字符串或整数值 进度令牌可以由发送者通过任何方式选择，但 必须 在所有活动请求中唯一。 { \"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"some_method\", \"params\": { \"_meta\": { \"progressToken\": \"abc123\" } } } 接收者 可以 然后发送包含以下内容的进度通知：\n原始进度令牌 到目前为止的当前进度值 可选的“总计”值 { \"jsonrpc\": \"2.0\", \"method\": \"notifications/progress\", \"params\": { \"progressToken\": \"abc123\", \"progress\": 50, \"total\": 100 } } 即使总数未知，progress 值 必须 随每个通知增加。 progress 和 total 值 可以 是浮点数。 "},"title":"进度"},"/specification/basic/versioning/":{"data":{"":"Model Context Protocol 使用基于字符串的版本标识符，格式为 YYYY-MM-DD，以指示最后一次进行向后不兼容更改的日期。\n当前协议版本为 2024-11-05。 查看所有修订。\nℹ️ 只要协议更新保持向后兼容，协议版本将 不会 增加。这允许在保持互操作性的同时进行增量改进。 版本协商发生在 初始化 期间。客户端和服务器 可以 同时支持多个协议版本，但它们 必须 就会话中使用的单一版本达成一致。\n如果版本协商失败，协议提供适当的错误处理，允许客户端在无法找到与服务器兼容的版本时优雅地终止连接。"},"title":"版本控制"},"/specification/client/":{"data":{"":" ℹ️ 协议修订: 2024-11-05 客户端可以实现其他功能，以丰富连接的 MCP 服务器：\nRoots Sampling "},"title":"客户端功能"},"/specification/client/roots/":{"data":{"":" ℹ️ 协议修订: 2024-11-05 Model Context Protocol (MCP) 提供了一种标准化方式，使客户端能够向服务器公开文件系统“根”。根定义了服务器在文件系统中可以操作的边界，使其了解可以访问的目录和文件。服务器可以从支持的客户端请求根列表，并在该列表更改时接收通知。","功能#功能":"支持根的客户端 必须 在 初始化 期间声明 roots 功能：\n{ \"capabilities\": { \"roots\": { \"listChanged\": true } } } listChanged 表示客户端是否会在根列表更改时发出通知。","协议消息#协议消息":"列出根 要检索根，服务器发送 roots/list 请求：\n请求:\n{ \"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"roots/list\" } 响应:\n{ \"jsonrpc\": \"2.0\", \"id\": 1, \"result\": { \"roots\": [ { \"uri\": \"file:///home/user/projects/myproject\", \"name\": \"My Project\" } ] } } 根列表更改 当根更改时，支持 listChanged 的客户端 必须 发送通知：\n{ \"jsonrpc\": \"2.0\", \"method\": \"notifications/roots/list_changed\" } ","安全考虑#安全考虑":" 客户端 必须:\n仅公开具有适当权限的根 验证所有根 URI 以防止路径遍历 实施适当的访问控制 监控根的可访问性 服务器 应:\n处理根变得不可用的情况 在操作期间尊重根边界 验证所有路径是否符合提供的根 ","实施指南#实施指南":" 客户端 应:\n在向服务器公开根之前提示用户同意 提供清晰的用户界面进行根管理 在公开之前验证根的可访问性 监控根的更改 服务器 应:\n在使用之前检查根功能 优雅地处理根列表更改 在操作中尊重根边界 适当地缓存根信息 ","数据类型#数据类型":"根 根定义包括：\nuri: 根的唯一标识符。在当前规范中，这 必须 是 file:// URI。 name: 用于显示目的的可选人类可读名称。 不同用例的示例根：\n项目目录 { \"uri\": \"file:///home/user/projects/myproject\", \"name\": \"My Project\" } 多个存储库 [ { \"uri\": \"file:///home/user/repos/frontend\", \"name\": \"Frontend Repository\" }, { \"uri\": \"file:///home/user/repos/backend\", \"name\": \"Backend Repository\" } ] ","消息流程#消息流程":"sequenceDiagram participant Server participant Client Note over Server,Client: 发现 Server-\u003e\u003eClient: roots/list Client--\u003e\u003eServer: 可用根 Note over Server,Client: 更改 Client--)Server: notifications/roots/list_changed Server-\u003e\u003eClient: roots/list Client--\u003e\u003eServer: 更新根","用户交互模型#用户交互模型":"MCP 中的根通常通过工作区或项目配置界面公开。\n例如，实现可以提供一个工作区/项目选择器，允许用户选择服务器应有权访问的目录和文件。这可以与版本控制系统或项目文件的自动工作区检测相结合。\n然而，实现可以通过任何适合其需求的界面模式公开根—协议本身不强制规定任何特定的用户交互模型。","错误处理#错误处理":"客户端 应 返回标准 JSON-RPC 错误以处理常见故障情况：\n客户端不支持根: -32601 (方法未找到) 内部错误: -32603 错误示例:\n{ \"jsonrpc\": \"2.0\", \"id\": 1, \"error\": { \"code\": -32601, \"message\": \"不支持根\", \"data\": { \"reason\": \"客户端没有根功能\" } } } "},"title":"Roots"},"/specification/client/sampling/":{"data":{"":" ℹ️ 协议修订: 2024-11-05 Model Context Protocol (MCP) 提供了一种标准化方式，使服务器能够通过客户端请求 LLM 采样（“完成”或“生成”）。此流程允许客户端保持对模型访问、选择和权限的控制，同时使服务器能够利用 AI 功能—无需服务器 API 密钥。服务器可以请求基于文本或图像的交互，并可选择在其提示中包含来自 MCP 服务器的上下文。","功能#功能":"支持采样的客户端 必须 在 初始化 期间声明 sampling 功能：\n{ \"capabilities\": { \"sampling\": {} } } ","协议消息#协议消息":"创建消息 要请求语言模型生成，服务器发送 sampling/createMessage 请求：\n请求:\n{ \"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"sampling/createMessage\", \"params\": { \"messages\": [ { \"role\": \"user\", \"content\": { \"type\": \"text\", \"text\": \"法国的首都是哪里？\" } } ], \"modelPreferences\": { \"hints\": [ { \"name\": \"claude-3-sonnet\" } ], \"intelligencePriority\": 0.8, \"speedPriority\": 0.5 }, \"systemPrompt\": \"你是一个乐于助人的助手。\", \"maxTokens\": 100 } } 响应:\n{ \"jsonrpc\": \"2.0\", \"id\": 1, \"result\": { \"role\": \"assistant\", \"content\": { \"type\": \"text\", \"text\": \"法国的首都是巴黎。\" }, \"model\": \"claude-3-sonnet-20240307\", \"stopReason\": \"endTurn\" } } ","安全考虑#安全考虑":" 客户端 应 实施用户批准控制 双方 应 验证消息内容 客户端 应 尊重模型偏好提示 客户端 应 实施速率限制 双方 必须 适当处理敏感数据 ","数据类型#数据类型":"消息 采样消息可以包含：\n文本内容 { \"type\": \"text\", \"text\": \"消息内容\" } 图像内容 { \"type\": \"image\", \"data\": \"base64 编码的图像数据\", \"mimeType\": \"image/jpeg\" } 模型偏好 MCP 中的模型选择需要仔细抽象，因为服务器和客户端可能使用不同的 AI 提供商，提供不同的模型。服务器不能简单地按名称请求特定模型，因为客户端可能无法访问该模型，或者可能更喜欢使用不同提供商的等效模型。\n为了解决这个问题，MCP 实现了一个偏好系统，将抽象能力优先级与可选的模型提示相结合：\n能力优先级 服务器通过三个归一化的优先级值（0-1）表达其需求：\ncostPriority: 最小化成本的重要性？较高的值偏向于更便宜的模型。 speedPriority: 低延迟的重要性？较高的值偏向于更快的模型。 intelligencePriority: 高级功能的重要性？较高的值偏向于更强大的模型。 模型提示 虽然优先级有助于根据特性选择模型，但 hints 允许服务器建议特定模型或模型系列：\n提示被视为子字符串，可以灵活地匹配模型名称 多个提示按优先顺序评估 客户端 可以 将提示映射到不同提供商的等效模型 提示是建议性的—客户端做出最终的模型选择 例如:\n{ \"hints\": [ {\"name\": \"claude-3-sonnet\"}, // 更喜欢 Sonnet 类模型 {\"name\": \"claude\"} // 回退到任何 Claude 模型 ], \"costPriority\": 0.3, // 成本不太重要 \"speedPriority\": 0.8, // 速度非常重要 \"intelligencePriority\": 0.5 // 中等能力需求 } 客户端处理这些偏好，从其可用选项中选择适当的模型。例如，如果客户端无法访问 Claude 模型，但有 Gemini，它可能会根据类似的能力将 sonnet 提示映射到 gemini-1.5-pro。","消息流程#消息流程":"sequenceDiagram participant Server participant Client participant User participant LLM Note over Server,Client: 服务器启动采样 Server-\u003e\u003eClient: sampling/createMessage Note over Client,User: 人在循环中审查 Client-\u003e\u003eUser: 提出请求以供批准 User--\u003e\u003eClient: 审查并批准/修改 Note over Client,LLM: 模型交互 Client-\u003e\u003eLLM: 转发批准的请求 LLM--\u003e\u003eClient: 返回生成 Note over Client,User: 响应审查 Client-\u003e\u003eUser: 提出响应以供批准 User--\u003e\u003eClient: 审查并批准/修改 Note over Server,Client: 完成请求 Client--\u003e\u003eServer: 返回批准的响应","用户交互模型#用户交互模型":"MCP 中的采样允许服务器实现代理行为，通过使 LLM 调用 嵌套 在其他 MCP 服务器功能中来实现。\n实现可以通过任何适合其需求的界面模式公开采样—协议本身不强制规定任何特定的用户交互模型。\n⚠️ 出于信任与安全和安全考虑，应 始终有一个人在循环中，能够拒绝采样请求。\n应用程序 应：\n提供易于直观地审查采样请求的 UI 允许用户在发送前查看和编辑提示 在交付前呈现生成的响应以供审查 ","错误处理#错误处理":"客户端 应 返回常见故障情况的错误：\n错误示例:\n{ \"jsonrpc\": \"2.0\", \"id\": 1, \"error\": { \"code\": -1, \"message\": \"用户拒绝了采样请求\" } } "},"title":"采样"},"/specification/contributing/":{"data":{"":"我们欢迎社区的贡献！请查看我们的 贡献指南 了解如何提交更改的详细信息。\n所有贡献者必须遵守我们的 行为准则。\n如有问题和讨论，请使用 GitHub Discussions。"},"title":"贡献"},"/specification/revisions/":{"data":{"":"此页面列出了 Model Context Protocol 的不同修订版。有关协议版本控制的更多信息，请参见 版本控制。\n修订版可能标记为：\n草案: 正在进行的规范，尚未准备好供使用。 当前: 当前的协议版本，已准备好使用，并可能继续接收 向后兼容的更改。 最终: 过去的、完整的规范，不会再更改。 "},"title":"修订"},"/specification/revisions/2024-11-05/":{"data":{"":"这是当前版本的规范。此修订版可能会继续接收向后兼容的更改。"},"title":"2024-11-05 (当前)"},"/specification/server/":{"data":{"":" ℹ️ 协议修订: 2024-11-05 服务器通过 MCP 提供了为语言模型添加上下文的基本构建块。这些原语使客户端、服务器和语言模型之间的丰富交互成为可能：\n提示: 预定义的模板或指令，用于指导语言模型交互 资源: 提供给模型的结构化数据或内容，提供额外的上下文 工具: 可执行的函数，允许模型执行操作或检索信息 每个原语可以在以下控制层次结构中总结：\n原语 控制 描述 示例 提示 用户控制 由用户选择调用的交互模板 斜杠命令、菜单选项 资源 应用程序控制 由客户端附加和管理的上下文数据 文件内容、git 历史 工具 模型控制 暴露给 LLM 的函数，用于执行操作或检索信息 API POST 请求、文件写入 在下方详细了解这些关键原语：\nPrompts Resources Tools "},"title":"服务器功能"},"/specification/server/prompts/":{"data":{"":" ℹ️ 协议修订: 2024-11-05 Model Context Protocol (MCP) 提供了一种标准化方式，使服务器能够向客户端公开提示模板。提示允许服务器提供结构化消息和指令，以便与语言模型交互。客户端可以发现可用的提示，检索其内容，并提供参数以自定义它们。","功能#功能":"支持提示的服务器 必须 在 初始化 期间声明 prompts 功能：\n{ \"capabilities\": { \"prompts\": { \"listChanged\": true } } } listChanged 表示服务器是否会在可用提示列表更改时发出通知。","协议消息#协议消息":"列出提示 要检索可用的提示，客户端发送 prompts/list 请求。此操作支持 分页。\n请求:\n{ \"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"prompts/list\", \"params\": { \"cursor\": \"optional-cursor-value\" } } 响应:\n{ \"jsonrpc\": \"2.0\", \"id\": 1, \"result\": { \"prompts\": [ { \"name\": \"code_review\", \"description\": \"请求 LLM 分析代码质量并提出改进建议\", \"arguments\": [ { \"name\": \"code\", \"description\": \"要审查的代码\", \"required\": true } ] } ], \"nextCursor\": \"next-page-cursor\" } } 获取提示 要检索特定提示，客户端发送 prompts/get 请求。参数可以通过 完成 API 自动完成。\n请求:\n{ \"jsonrpc\": \"2.0\", \"id\": 2, \"method\": \"prompts/get\", \"params\": { \"name\": \"code_review\", \"arguments\": { \"code\": \"def hello():\\n print('world')\" } } } 响应:\n{ \"jsonrpc\": \"2.0\", \"id\": 2, \"result\": { \"description\": \"代码审查提示\", \"messages\": [ { \"role\": \"user\", \"content\": { \"type\": \"text\", \"text\": \"请审查这段 Python 代码：\\ndef hello():\\n print('world')\" } } ] } } 列表更改通知 当可用提示列表更改时，声明了 listChanged 功能的服务器 应 发送通知：\n{ \"jsonrpc\": \"2.0\", \"method\": \"notifications/prompts/list_changed\" } ","安全#安全":"实现 必须 仔细验证所有提示输入和输出，以防止注入攻击或未经授权访问资源。","实施考虑#实施考虑":" 服务器 应 在处理之前验证提示参数 客户端 应 处理大型提示列表的分页 双方 应 尊重功能协商 ","数据类型#数据类型":"提示 提示定义包括：\nname: 提示的唯一标识符 description: 可选的人类可读描述 arguments: 可选的自定义参数列表 提示消息 提示中的消息可以包含：\nrole: 表示说话者的“user”或“assistant” content: 以下内容类型之一： 文本内容 文本内容表示纯文本消息：\n{ \"type\": \"text\", \"text\": \"消息的文本内容\" } 这是用于自然语言交互的最常见内容类型。\n图像内容 图像内容允许在消息中包含视觉信息：\n{ \"type\": \"image\", \"data\": \"base64 编码的图像数据\", \"mimeType\": \"image/png\" } 图像数据 必须 进行 base64 编码，并包含有效的 MIME 类型。这使得在视觉上下文重要的情况下进行多模态交互成为可能。\n嵌入资源 嵌入资源允许在消息中直接引用服务器端资源：\n{ \"type\": \"resource\", \"resource\": { \"uri\": \"resource://example\", \"mimeType\": \"text/plain\", \"text\": \"资源内容\" } } 资源可以包含文本或二进制（blob）数据，并且 必须 包括：\n有效的资源 URI 适当的 MIME 类型 文本内容或 base64 编码的 blob 数据 嵌入资源使提示能够无缝地将服务器管理的内容（如文档、代码示例或其他参考材料）直接纳入对话流程中。","消息流程#消息流程":"sequenceDiagram participant Client participant Server Note over Client,Server: 发现 Client-\u003e\u003eServer: prompts/list Server--\u003e\u003eClient: 提示列表 Note over Client,Server: 使用 Client-\u003e\u003eServer: prompts/get Server--\u003e\u003eClient: 提示内容 opt listChanged Note over Client,Server: 更改 Server--)Client: prompts/list_changed Client-\u003e\u003eServer: prompts/list Server--\u003e\u003eClient: 更新的提示 end","用户交互模型#用户交互模型":"提示设计为 用户控制，这意味着它们从服务器公开给客户端，目的是让用户能够明确选择它们进行使用。\n通常，提示会通过用户界面中的用户发起命令触发，这允许用户自然地发现和调用可用的提示。\n例如，作为斜杠命令：\n然而，实现者可以通过任何适合其需求的界面模式公开提示—协议本身不强制规定任何特定的用户交互模型。","错误处理#错误处理":"服务器 应 返回标准 JSON-RPC 错误以处理常见故障情况：\n无效的提示名称: -32602 (无效参数) 缺少必需参数: -32602 (无效参数) 内部错误: -32603 (内部错误) "},"title":"提示"},"/specification/server/resources/":{"data":{"":" ℹ️ 协议修订: 2024-11-05 Model Context Protocol (MCP) 提供了一种标准化方式，使服务器能够向客户端公开资源。资源允许服务器共享为语言模型提供上下文的数据，例如文件、数据库模式或特定于应用程序的信息。每个资源都由一个 URI 唯一标识。","功能#功能":"支持资源的服务器 必须 声明 resources 功能：\n{ \"capabilities\": { \"resources\": { \"subscribe\": true, \"listChanged\": true } } } 该功能支持两个可选功能：\nsubscribe: 客户端是否可以订阅以接收单个资源更改的通知。 listChanged: 服务器是否会在可用资源列表更改时发出通知。 subscribe 和 listChanged 都是可选的—服务器可以支持两者、任一或都不支持：\n{ \"capabilities\": { \"resources\": {} // 不支持任何功能 } } { \"capabilities\": { \"resources\": { \"subscribe\": true // 仅支持订阅 } } } { \"capabilities\": { \"resources\": { \"listChanged\": true // 仅支持列表更改通知 } } } ","协议消息#协议消息":"列出资源 要发现可用资源，客户端发送 resources/list 请求。此操作支持 分页。\n请求:\n{ \"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"resources/list\", \"params\": { \"cursor\": \"optional-cursor-value\" } } 响应:\n{ \"jsonrpc\": \"2.0\", \"id\": 1, \"result\": { \"resources\": [ { \"uri\": \"file:///project/src/main.rs\", \"name\": \"main.rs\", \"description\": \"主要应用程序入口点\", \"mimeType\": \"text/x-rust\" } ], \"nextCursor\": \"next-page-cursor\" } } 读取资源 要检索资源内容，客户端发送 resources/read 请求：\n请求:\n{ \"jsonrpc\": \"2.0\", \"id\": 2, \"method\": \"resources/read\", \"params\": { \"uri\": \"file:///project/src/main.rs\" } } 响应:\n{ \"jsonrpc\": \"2.0\", \"id\": 2, \"result\": { \"contents\": [ { \"uri\": \"file:///project/src/main.rs\", \"mimeType\": \"text/x-rust\", \"text\": \"fn main() {\\n println!(\\\"Hello world!\\\");\\n}\" } ] } } 资源模板 资源模板允许服务器使用 URI 模板 公开参数化资源。参数可以通过 完成 API 自动完成。\n请求:\n{ \"jsonrpc\": \"2.0\", \"id\": 3, \"method\": \"resources/templates/list\" } 响应:\n{ \"jsonrpc\": \"2.0\", \"id\": 3, \"result\": { \"resourceTemplates\": [ { \"uriTemplate\": \"file:///{path}\", \"name\": \"项目文件\", \"description\": \"访问项目目录中的文件\", \"mimeType\": \"application/octet-stream\" } ] } } 列表更改通知 当可用资源列表更改时，声明了 listChanged 功能的服务器 应 发送通知：\n{ \"jsonrpc\": \"2.0\", \"method\": \"notifications/resources/list_changed\" } 订阅 该协议支持对资源更改的可选订阅。客户端可以订阅特定资源，并在其更改时接收通知：\n订阅请求:\n{ \"jsonrpc\": \"2.0\", \"id\": 4, \"method\": \"resources/subscribe\", \"params\": { \"uri\": \"file:///project/src/main.rs\" } } 更新通知:\n{ \"jsonrpc\": \"2.0\", \"method\": \"notifications/resources/updated\", \"params\": { \"uri\": \"file:///project/src/main.rs\" } } ","安全考虑#安全考虑":" 服务器 必须 验证所有资源 URI 应 对敏感资源实施访问控制 二进制数据 必须 进行适当编码 在操作之前 应 检查资源权限 ","常见-uri-方案#常见 URI 方案":"该协议定义了几种标准 URI 方案。此列表并不详尽—实现者始终可以使用其他自定义 URI 方案。\nhttps:// 用于表示可在网上获取的资源。\n服务器 应 仅在客户端能够直接从网上获取和加载资源时使用此方案—即不需要通过 MCP 服务器读取资源。\n对于其他用例，服务器 应 优先使用其他 URI 方案，或定义自定义方案，即使服务器本身将通过互联网下载资源内容。\nfile:// 用于标识行为类似于文件系统的资源。然而，资源不需要映射到实际的物理文件系统。\nMCP 服务器 可以 使用 XDG MIME 类型 标识 file:// 资源，如 inode/directory，以表示没有标准 MIME 类型的非常规文件（如目录）。\ngit:// Git 版本控制集成。","数据类型#数据类型":"资源 资源定义包括：\nuri: 资源的唯一标识符 name: 人类可读名称 description: 可选描述 mimeType: 可选 MIME 类型 资源内容 资源可以包含文本或二进制数据：\n文本内容 { \"uri\": \"file:///example.txt\", \"mimeType\": \"text/plain\", \"text\": \"资源内容\" } 二进制内容 { \"uri\": \"file:///example.png\", \"mimeType\": \"image/png\", \"blob\": \"base64 编码的数据\" } ","消息流程#消息流程":"sequenceDiagram participant Client participant Server Note over Client,Server: 资源发现 Client-\u003e\u003eServer: resources/list Server--\u003e\u003eClient: 资源列表 Note over Client,Server: 资源访问 Client-\u003e\u003eServer: resources/read Server--\u003e\u003eClient: 资源内容 Note over Client,Server: 订阅 Client-\u003e\u003eServer: resources/subscribe Server--\u003e\u003eClient: 订阅确认 Note over Client,Server: 更新 Server--)Client: notifications/resources/updated Client-\u003e\u003eServer: resources/read Server--\u003e\u003eClient: 更新的内容","用户交互模型#用户交互模型":"MCP 中的资源设计为 应用程序驱动，主机应用程序根据其需求确定如何包含上下文。\n例如，应用程序可以：\n通过 UI 元素公开资源，以供显式选择，显示为树或列表视图 允许用户搜索和过滤可用资源 实现基于启发式或 AI 模型选择的自动上下文包含 然而，实现者可以通过任何适合其需求的界面模式公开资源—协议本身不强制规定任何特定的用户交互模型。","错误处理#错误处理":"服务器 应 返回标准 JSON-RPC 错误以处理常见故障情况：\n找不到资源: -32002 内部错误: -32603 错误示例:\n{ \"jsonrpc\": \"2.0\", \"id\": 5, \"error\": { \"code\": -32002, \"message\": \"找不到资源\", \"data\": { \"uri\": \"file:///nonexistent.txt\" } } } "},"title":"资源"},"/specification/server/tools/":{"data":{"":" ℹ️ 协议修订: 2024-11-05 Model Context Protocol (MCP) 允许服务器公开可以由语言模型调用的工具。工具使模型能够与外部系统交互，例如查询数据库、调用 API 或执行计算。每个工具都由一个名称唯一标识，并包含描述其模式的元数据。","功能#功能":"支持工具的服务器 必须 声明 tools 功能：\n{ \"capabilities\": { \"tools\": { \"listChanged\": true } } } listChanged 表示服务器是否会在可用工具列表更改时发出通知。","协议消息#协议消息":"列出工具 要发现可用工具，客户端发送 tools/list 请求。此操作支持 分页。\n请求:\n{ \"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"tools/list\", \"params\": { \"cursor\": \"optional-cursor-value\" } } 响应:\n{ \"jsonrpc\": \"2.0\", \"id\": 1, \"result\": { \"tools\": [ { \"name\": \"get_weather\", \"description\": \"获取某地的当前天气信息\", \"inputSchema\": { \"type\": \"object\", \"properties\": { \"location\": { \"type\": \"string\", \"description\": \"城市名称或邮政编码\" } }, \"required\": [\"location\"] } } ], \"nextCursor\": \"next-page-cursor\" } } 调用工具 要调用工具，客户端发送 tools/call 请求：\n请求:\n{ \"jsonrpc\": \"2.0\", \"id\": 2, \"method\": \"tools/call\", \"params\": { \"name\": \"get_weather\", \"arguments\": { \"location\": \"New York\" } } } 响应:\n{ \"jsonrpc\": \"2.0\", \"id\": 2, \"result\": { \"content\": [{ \"type\": \"text\", \"text\": \"纽约当前天气：\\n温度：72°F\\n天气状况：局部多云\" }], \"isError\": false } } 列表更改通知 当可用工具列表更改时，声明了 listChanged 功能的服务器 应 发送通知：\n{ \"jsonrpc\": \"2.0\", \"method\": \"notifications/tools/list_changed\" } ","安全考虑#安全考虑":" 服务器 必须：\n验证所有工具输入 实施适当的访问控制 限制工具调用速率 清理工具输出 客户端 应：\n对敏感操作提示用户确认 在调用服务器之前向用户显示工具输入，以避免恶意或意外的数据泄露 在传递给 LLM 之前验证工具结果 为工具调用实现超时 记录工具使用情况以供审计 ","数据类型#数据类型":"工具 工具定义包括：\nname: 工具的唯一标识符 description: 功能的人类可读描述 inputSchema: 定义预期参数的 JSON 模式 工具结果 工具结果可以包含多种类型的多个内容项：\n文本内容 { \"type\": \"text\", \"text\": \"工具结果文本\" } 图像内容 { \"type\": \"image\", \"data\": \"base64 编码的数据\", \"mimeType\": \"image/png\" } 嵌入资源 资源 可以 嵌入，以提供额外的上下文或数据，位于可以订阅或稍后由客户端再次获取的 URI 后面：\n{ \"type\": \"resource\", \"resource\": { \"uri\": \"resource://example\", \"mimeType\": \"text/plain\", \"text\": \"资源内容\" } } ","消息流程#消息流程":"sequenceDiagram participant LLM participant Client participant Server Note over Client,Server: 发现 Client-\u003e\u003eServer: tools/list Server--\u003e\u003eClient: 工具列表 Note over Client,LLM: 工具选择 LLM-\u003e\u003eClient: 选择要使用的工具 Note over Client,Server: 调用 Client-\u003e\u003eServer: tools/call Server--\u003e\u003eClient: 工具结果 Client-\u003e\u003eLLM: 处理结果 Note over Client,Server: 更新 Server--)Client: tools/list_changed Client-\u003e\u003eServer: tools/list Server--\u003e\u003eClient: 更新的工具","用户交互模型#用户交互模型":"MCP 中的工具设计为 模型控制，这意味着语言模型可以根据其上下文理解和用户的提示自动发现和调用工具。\n然而，实现者可以通过任何适合其需求的界面模式公开工具—协议本身不强制规定任何特定的用户交互模型。\n⚠️ 出于信任与安全和安全考虑，应 始终有一个人在循环中，能够拒绝工具调用。\n应用程序 应：\n提供 UI，清楚地显示哪些工具暴露给 AI 模型 在工具调用时插入清晰的视觉指示器 向用户呈现确认提示，以确保人在循环中 ","错误处理#错误处理":"工具使用两种错误报告机制：\n协议错误: 标准 JSON-RPC 错误，用于以下问题：\n未知工具 无效参数 服务器错误 工具执行错误: 在工具结果中报告，带有 isError: true：\nAPI 失败 无效输入数据 业务逻辑错误 协议错误示例:\n{ \"jsonrpc\": \"2.0\", \"id\": 3, \"error\": { \"code\": -32602, \"message\": \"未知工具：invalid_tool_name\" } } 工具执行错误示例:\n{ \"jsonrpc\": \"2.0\", \"id\": 4, \"result\": { \"content\": [{ \"type\": \"text\", \"text\": \"获取天气数据失败：API 速率限制超出\" }], \"isError\": true } } "},"title":"工具"},"/specification/server/utilities/":{"data":{"":" ℹ️ 协议修订: 2024-11-05 这些可选功能可用于增强服务器功能。\n完成 日志记录 分页 "},"title":"实用工具"},"/specification/server/utilities/completion/":{"data":{"":" ℹ️ 协议修订: 2024-11-05 Model Context Protocol (MCP) 提供了一种标准化方式，使服务器能够为提示和资源 URI 提供参数自动完成建议。这使用户在输入参数值时能够获得上下文建议，从而实现类似于 IDE 的丰富体验。","协议消息#协议消息":"请求完成 要获取完成建议，客户端发送 completion/complete 请求，指定通过引用类型完成的内容：\n请求:\n{ \"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"completion/complete\", \"params\": { \"ref\": { \"type\": \"ref/prompt\", \"name\": \"code_review\" }, \"argument\": { \"name\": \"language\", \"value\": \"py\" } } } 响应:\n{ \"jsonrpc\": \"2.0\", \"id\": 1, \"result\": { \"completion\": { \"values\": [\"python\", \"pytorch\", \"pyside\"], \"total\": 10, \"hasMore\": true } } } 引用类型 该协议支持两种类型的完成引用：\n类型 描述 示例 ref/prompt 按名称引用提示 {\"type\": \"ref/prompt\", \"name\": \"code_review\"} ref/resource 引用资源 URI {\"type\": \"ref/resource\", \"uri\": \"file:///{path}\"} 完成结果 服务器返回按相关性排序的完成值数组，其中包括：\n每个响应最多 100 个项目 可选的可用匹配总数 指示是否存在其他结果的布尔值 ","安全#安全":"实现 必须：\n验证所有完成输入 实施适当的速率限制 控制对敏感建议的访问 防止基于完成的信息泄露 ","实施考虑#实施考虑":" 服务器 应：\n返回按相关性排序的建议 在适当的情况下实现模糊匹配 限制完成请求的速率 验证所有输入 客户端 应：\n对快速完成请求进行去抖动 在适当的情况下缓存完成结果 优雅地处理缺失或部分结果 ","数据类型#数据类型":"CompleteRequest ref: 一个 PromptReference 或 ResourceReference argument: 包含以下内容的对象： name: 参数名称 value: 当前值 CompleteResult completion: 包含以下内容的对象： values: 建议数组（最多 100 个） total: 可选的匹配总数 hasMore: 其他结果标志 ","消息流程#消息流程":"sequenceDiagram participant Client participant Server Note over Client: 用户输入参数 Client-\u003e\u003eServer: completion/complete Server--\u003e\u003eClient: 完成建议 Note over Client: 用户继续输入 Client-\u003e\u003eServer: completion/complete Server--\u003e\u003eClient: 细化建议","用户交互模型#用户交互模型":"MCP 中的完成设计支持类似于 IDE 代码完成的交互用户体验。\n例如，应用程序可以在用户输入时在下拉菜单或弹出菜单中显示完成建议，并能够从可用选项中进行过滤和选择。\n然而，实现者可以通过任何适合其需求的界面模式公开完成—协议本身不强制规定任何特定的用户交互模型。"},"title":"完成"},"/specification/server/utilities/logging/":{"data":{"":" ℹ️ 协议修订: 2024-11-05 Model Context Protocol (MCP) 提供了一种标准化方式，使服务器能够向客户端发送结构化日志消息。客户端可以通过设置最小日志级别来控制日志记录的详细程度，服务器发送包含严重级别、可选记录器名称和任意 JSON 可序列化数据的通知。","功能#功能":"发送日志消息通知的服务器 必须 声明 logging 功能：\n{ \"capabilities\": { \"logging\": {} } } ","协议消息#协议消息":"设置日志级别 要配置最小日志级别，客户端 可以 发送 logging/setLevel 请求：\n请求:\n{ \"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"logging/setLevel\", \"params\": { \"level\": \"info\" } } 日志消息通知 服务器使用 notifications/message 通知发送日志消息：\n{ \"jsonrpc\": \"2.0\", \"method\": \"notifications/message\", \"params\": { \"level\": \"error\", \"logger\": \"database\", \"data\": { \"error\": \"连接失败\", \"details\": { \"host\": \"localhost\", \"port\": 5432 } } } } ","安全#安全":" 日志消息 不得 包含：\n凭据或密钥 个人身份信息 可能帮助攻击的内部系统详细信息 实现 应：\n限制消息速率 验证所有数据字段 控制日志访问 监控敏感内容 ","实施考虑#实施考虑":" 服务器 应：\n限制日志消息的速率 在数据字段中包含相关上下文 使用一致的记录器名称 删除敏感信息 客户端 可以：\n在 UI 中显示日志消息 实现日志过滤/搜索 以视觉方式显示严重性 持久化日志消息 ","日志级别#日志级别":"该协议遵循 RFC 5424 中指定的标准 syslog 严重级别：\n级别 描述 示例用例 debug 详细的调试信息 函数入口/退出点 info 一般信息性消息 操作进度更新 notice 正常但重要的事件 配置更改 warning 警告条件 使用已弃用的功能 error 错误条件 操作失败 critical 严重条件 系统组件故障 alert 必须立即采取行动 检测到数据损坏 emergency 系统不可用 完全系统故障 ","消息流程#消息流程":"sequenceDiagram participant Client participant Server Note over Client,Server: 配置日志记录 Client-\u003e\u003eServer: logging/setLevel (info) Server--\u003e\u003eClient: 空结果 Note over Client,Server: 服务器活动 Server--)Client: notifications/message (info) Server--)Client: notifications/message (warning) Server--)Client: notifications/message (error) Note over Client,Server: 级别更改 Client-\u003e\u003eServer: logging/setLevel (error) Server--\u003e\u003eClient: 空结果 Note over Server: 仅发送错误级别及以上","用户交互模型#用户交互模型":"实现者可以通过任何适合其需求的界面模式公开日志记录—协议本身不强制规定任何特定的用户交互模型。","错误处理#错误处理":"服务器 应 返回标准 JSON-RPC 错误以处理常见故障情况：\n无效的日志级别: -32602 (无效参数) 配置错误: -32603 (内部错误) "},"title":"日志记录"},"/specification/server/utilities/pagination/":{"data":{"":" ℹ️ 协议修订: 2024-11-05 Model Context Protocol (MCP) 支持对可能返回大量结果集的列表操作进行分页。分页允许服务器将结果分成较小的块，而不是一次性返回所有结果。\n分页在通过互联网连接到外部服务时尤为重要，但对于本地集成也很有用，以避免处理大型数据集时的性能问题。","分页模型#分页模型":"MCP 中的分页使用不透明的基于游标的方法，而不是编号页。\n游标 是一个不透明的字符串令牌，表示结果集中的位置 页面大小 由服务器确定，可能不会 固定 ","分页流程#分页流程":"sequenceDiagram participant Client participant Server Client-\u003e\u003eServer: 列表请求（无游标） loop 分页循环 Server--\u003e\u003eClient: 结果页 + nextCursor Client-\u003e\u003eServer: 列表请求（带游标） end","响应格式#响应格式":"分页开始时，服务器发送包含以下内容的 响应：\n当前页的结果 如果存在更多结果，则为可选的 nextCursor 字段 { \"jsonrpc\": \"2.0\", \"id\": \"123\", \"result\": { \"resources\": [...], \"nextCursor\": \"eyJwYWdlIjogM30=\" } } ","实施指南#实施指南":" 服务器 应：\n提供稳定的游标 优雅地处理无效游标 客户端 应：\n将缺少的 nextCursor 视为结果的结束 支持分页和非分页流程 客户端 必须 将游标视为不透明令牌：\n不要对游标格式做出假设 不要尝试解析或修改游标 不要跨会话持久化游标 ","支持分页的操作#支持分页的操作":"以下 MCP 操作支持分页：\nresources/list - 列出可用资源 resources/templates/list - 列出资源模板 prompts/list - 列出可用提示 tools/list - 列出可用工具 ","请求格式#请求格式":"收到游标后，客户端可以通过包含该游标的请求 继续 分页：\n{ \"jsonrpc\": \"2.0\", \"method\": \"resources/list\", \"params\": { \"cursor\": \"eyJwYWdlIjogMn0=\" } } ","错误处理#错误处理":"无效的游标 应 导致代码为 -32602（无效参数）的错误。"},"title":"分页"}}